from talon import Module, Context

# dummy speech engine for testing
from talon.engines.dummy import DummyEngine
from talon import speech_system
speech_system.add_engine(DummyEngine())

mod = Module()
ctx = Context()

### ALPHABET ###

# my alphabet
phonetic_alphabet = 'air bill cap drum each faint gust ham sit jury crunch little made near orange pink queen red sun trap urge vest winner plex yank zoo'

# letters
letters_string = 'abcdefghijklmnopqrstuvwxyz'

# alphabet dictionary
alpha_dict = dict(zip(phonetic_alphabet.split(' '), letters_string))

mod.list('letter_key', desc='Letter keys')

ctx.lists['self.letter_key'] = alpha_dict

@mod.capture(rule='{self.letter_key}')
def letter_key(m) -> str:
    'A letter key'
    return str(m)

### NUMERIC ###

numbers = 'zero one two three four five six seven eight nine'.split(' ')
numerals = '0123456789'

mod.list('number_key', desc='Number keys')
ctx.lists['self.number_key'] = dict(zip(numbers, numerals))

@mod.capture(rule='{self.number_key}')
def number_key(m) -> str:
    'A number key'
    return str(m)

### ARROWS ###

mod.list('arrow_key', desc='Arrow keys')

ctx.lists['self.arrow_key'] = {
    'up': 'up',
    'down': 'down',
    'left': 'left',
    'right': 'right'
}

@mod.capture(rule='{self.arrow_key}')
def arrow_key(m) -> str:
    'An arrow key'
    return str(m)

### SPECIAL CHARACTERS ###

mod.list('special_character', desc='Special characters')

ctx.lists['self.special_character'] = {
    # TODO: I'm not sure why we need these, I think it has something to do with
    # Dragon. Possibly it has been fixed by later improvements to talon? -rntz
    "`": "`",
    ",": ",",  # <== these things
    "back tick": "`",
    "comma": ",",
    "period": ".",
    "semicolon": ";",
    "colon": ":",
    "forward slash": "/",
    "question mark": "?",
    "exclamation mark": "!",
    "exclamation point": "!",
    "dollar sign": "$",
    "asterisk": "*",
    "hash sign": "#",
    "number sign": "#",
    "percent sign": "%",
    "at sign": "@",
    "and sign": "&",
    "ampersand": "&",
    "dot": ".",
    "quote": "'",
    "L square": "[",
    "left square": "[",
    "square": "[",
    "R square": "]",
    "right square": "]",
    "slash": "/",
    "backslash": "\\",
    "minus": "-",
    "dash": "-",
    "equals": "=",
    "plus": "+",
    "tilde": "~",
    "bang": "!",
    "dollar": "$",
    "down score": "_",
    "under score": "_",
    "paren": "(",
    "L paren": "(",
    "left paren": "(",
    "R paren": ")",
    "right paren": ")",
    "brace": "{",
    "left brace": "{",
    "R brace": "}",
    "right brace": "}",
    "angle": "<",
    "left angle": "<",
    "less than": "<",
    "rangle": ">",
    "R angle": ">",
    "right angle": ">",
    "greater than": ">",
    "star": "*",
    "pound": "#",
    "hash": "#",
    "percent": "%",
    "caret": "^",
    "amper": "&",
    "pipe": "|",
    "dubquote": '"',
    "double quote": '"',
}

@mod.capture(rule="{self.special_character}")
def special_character(m) -> str:
    'A special character'
    return str(m)

### OTHER ###



### MODIFIERS ###

mod.list('modifier_key', desc='Modifier keys')

ctx.lists['self.modifier_key'] = {
    'command': 'cmd',
    'option': 'alt',
    'control': 'ctrl',
    'shift': 'shift'
}

@mod.capture(rule='{self.modifier_key}+')
def modifier_keys(m) -> str:
    'One or more modifier keys.'
    return '-'.join(m.modifier_key_list)

@mod.capture(rule='<self.modifier_keys> <self.letter_key>')
def modified_key(m) -> str:
    'A modifier key'
    return '-'.join([m.modifier_keys, m.letter_key])

### KEYS ###

@mod.capture(
    rule='( <self.letter_key> | <self.number_key> | <self.arrow_key> | '
    '<self.special_character> )'
)
def unmodified_key(m) -> str:
    'A single unmodified key'
    return str(m)

@mod.capture(rule='<self.modifier_keys>* <self.unmodified_key>')
def key(m) -> str:
    'A single key with optional modifiers'
    try:
        mods = m.modifier_keys_list
    except AttributeError:
        mods = []
    return '-'.join(mods + [m.unmodified_key])
